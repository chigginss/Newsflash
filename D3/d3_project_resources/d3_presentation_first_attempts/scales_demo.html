<!DOCTYPE html>
<html>
<body>
    <head>
      <link href='style.css' rel='stylesheet'>
    </head>
    <h1>Scales and Events</h1>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>

       let data = [
                {art_title: 'Senators Urge Pompeo', news_source: 'The New York Times', popularity: 10},
                {art_title: 'test test test', news_source: 'Politico', popularity: 5},
                {art_title: 'test test test', news_source: 'CNN', popularity: 1},
                {art_title: 'test test test', news_source: 'The Wall Street Journal', popularity: 7},
                {art_title: 'test test test', news_source: 'NBC news', popularity: 3},
                {art_title: 'test test test', news_source: 'Politico', popularity: 5},
                {art_title: 'Fears of a U.S.', news_source: 'Washington Post',popularity: 9},
       ];

       // // Here we're creating a scale in order to properly size our 
       // // circles based on constantly changing data sets.
       
       // // The domain of possibilities  for the rating can be defined as
       // // the min and max of all of the rating values from our data.
       
       // // The range of actual pixel size values we want to see is 100px to
       // // 300 px-- a reasonable range such that circles aren't going to be
       // // absurdly large if someone rates highly, or absurdly tiny if 
       // // someone gives a low rating.

       // // The variable sizeScale is now a function (Yes, a function) that
       // // takes a single parameter-- a rating value. It returns the correct
       // // pixel radius scaled according to our domain and range.

       let minData = d3.min(data, (d) => d.popularity);
       let maxData = d3.max(data, (d) => d.popularity);

       let sizeScale = d3.scaleLinear()
         .domain([minData, maxData])
         .range([30, 100]);

       // // An ordinal scale is slightly different that the linear scale used 
       // // above. Here, we can associate completely non-numeric values with
       // // other values.

       // // For further study on colors in D3, check out D3's built in color
       // // groupings, such as d3.schemeCategory10, d3.schemeCategory20. These
       // // are out-of-the-box color groupings of 10, 20, etc. that can be 
       // // used to quickly generate good looking color combos.
       // // Below is the syntax if you'd like to try this out. 
       // // let colorScale = d3.scaleOrdinal(d3.schemeCategory10);

       let colorScale = d3.scaleOrdinal(['pink', 'blue', 'orange', 'green']);


       // For the lateral position of the circles/lavels on the X axis, we'll
       // also need a x scale. The domain will be the same as the sizeScale,
       // but the range is the length, in pixels, of our X axis.

      let xScale = d3.scaleLinear()
         .domain([minData, maxData])
         .range([0, 700]);
       
    var svgContainer = d3.select("body")
        .append("svg")
        .attr("width", 800)
        .attr("height", 1000);

       // In D3, it's more common that you start with an empty page,
       // but have data. So, we create a selection on the basis of class
       // that nothing on the page currently has- "movie-node".
       var groups = svgContainer.selectAll('.article-node')
                     .data(data)
                     .enter()
                     .append('g')
                     .attr("class", "article-node");


       groups.append('circle')
             .attr('r', (d) => sizeScale(d.popularity))
             .attr('cx', (d) => xScale(d.popularity))
             .attr('cy', 100)
             .style('fill', (d) => colorScale(d.art_title));

       groups.append('text')
             .attr('x', (d) => xScale(d.popularity))
             .attr('y', 100)
             .text((d) => d.art_title);


      // Add an actual x axis to the visualization by creating an
      // axis based on the same xScale we used to determine the x-position
      // of our circles above.

      let xAxis = d3.axisBottom(xScale);

      // This next line actually adds the axis to the DOM.
      // The tranform is moving the axis from the default position at the top
      // of the screen to 300 pixels down.

      svgContainer.append('g').call(xAxis)
          .attr("transform", "translate(0,300)");

      
      // Adding hover behavior

      function handleMouseover(d){
        svgContainer.append('text')
           .attr('x', xScale(d.popularity))
           .attr('y', (d) => 150)
           .text("description goes here"+d.news_source)
           .attr('id', 'tooltip'+d.news_source);
      }

      function handleMouseout(d){
        d3.select('#tooltip'+d.news_source).remove();
      }

      groups.on('mouseover', handleMouseover);
      groups.on('mouseout', handleMouseout);

    </script>

</body>


</html>